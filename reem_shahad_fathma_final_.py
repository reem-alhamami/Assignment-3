# -*- coding: utf-8 -*-
"""Reem-Shahad-Fathma - Final .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w1Z__Kx00PfpIleStAVAk4vYIZdi_6W8
"""

#USER & CUSTOMER CLASSES
class User:
    """
    Base class for a system user (can be Customer or Admin).
    """

    def __init__(self, user_id, name, email, password):
        # Private attributes for user info
        self.__user_id = user_id
        self.__name = name
        self.__email = email
        self.__password = password

    def login(self, password):
        # Check if the password matches
        return self.__password == password

    def logout(self):
        # Print logout message
        print(f"{self.__name} has logged out.")

    def __str__(self):
        # Return user as string
        return f"User: {self.__name} ({self.__email})"

    # Getter methods to access private attributes
    def get_user_id(self):
        return self.__user_id

    def get_name(self):
        return self.__name

    def get_email(self):
        return self.__email

    # Setter method to change name
    def set_name(self, name):
        if not name:
            raise ValueError("Name cannot be empty.")
        self.__name = name

    # Setter method to change email
    def set_email(self, email):
        if "@" not in email:
            raise ValueError("Invalid email address.")
        self.__email = email


class Customer(User):
    """
    Represents a Customer.
    Inherits from User and adds more features.
    """

    def __init__(self, user_id, name, email, password, visit_count=0):
        # Call parent constructor
        super().__init__(user_id, name, email, password)
        # Customer-specific attributes
        self.__visit_count = visit_count
        self.__orders = []  # List to store past orders

    def view_orders(self):
        # Show all orders
        if not self.__orders:
            print("No orders placed yet.")
        for order in self.__orders:
            print(order)

    def update_profile(self, name, email):
        # Update name and email
        self.set_name(name)
        self.set_email(email)
        print("Profile updated.")

    def add_order(self, order):
        # Add an order to history
        self.__orders.append(order)

    def get_visit_count(self):
        # Return visit count
        return self.__visit_count

    def __str__(self):
        # Return customer as string
        return f"Customer: {self.get_name()} ({self.get_email()})"

#Admin Class (Inherits User)


class Admin(User):
    """
    A class representing an Admin user who extends from User.
    Admins can manage tickets, view sales, and modify discounts.
    """

    def __init__(self, user_id, name, email, password, admin_level):
        """
        Initializes an Admin instance with the provided details.

        :param user_id: Unique identifier for the user
        :param name: User's name
        :param email: User's email address
        :param password: User's password
        :param admin_level: Level of access for the admin (e.g., BASIC, MANAGER)
        """
        super().__init__(user_id, name, email, password)  # Call parent class constructor
        self.__admin_level = admin_level  # Private attribute for admin level

    def view_ticket_sales(self):
        """
        Simulate viewing ticket sales.
        :return: Dictionary of sales per date.
        """
        return {"2025-07-01": 100, "2025-07-02": 120}  # Example data

    def update_discounts(self):
        """
        Simulate updating discounts.
        """
        print("Discounts updated.")  # Simple print to simulate functionality

    def manage_inventory(self):
        """
        Simulate managing ticket inventory.
        """
        print("Managing ticket inventory.")  # Another simple action

    def __str__(self):
        """
        Return a string showing admin info.
        """
        return f"Admin {self.get_name()} ({self.get_email()}), Level: {self.__admin_level}"

    def get_admin_level(self):
        """
        Return the admin level.
        """
        return self.__admin_level

#Ticket and Ticket Inventory Classes

from enum import Enum  # Import Enum for ticket types

class TicketType(Enum):
    """
    Enum for different types of tickets.
    """
    SINGLERACE = 1
    WEEKENDPASS = 2
    SEASONMEMBERSHIP = 3
    GROUPDISCOUNT = 4

class Ticket:
    """
    A class representing a ticket with various attributes.
    """

    def __init__(self, ticket_id, ticket_type, price, validity, race_date):
        """
        Initializes a Ticket instance.

        :param ticket_id: Unique identifier for the ticket
        :param ticket_type: Type of the ticket (from TicketType enum)
        :param price: Price of the ticket
        :param validity: Validity of the ticket
        :param race_date: Date of the race
        """
        self.ticket_id = ticket_id  # Store ticket ID
        self.ticket_type = ticket_type  # Store ticket type (enum)
        self.price = price  # Store price
        self.validity = validity  # Store validity
        self.race_date = race_date  # Store race date

    def __str__(self):
        """
        Return a string representation of the Ticket.
        """
        return f"Ticket ID: {self.ticket_id}, Type: {self.ticket_type.name}, Price: {self.price}, Date: {self.race_date}"

class TicketInventory:
    """
    A class representing the inventory of tickets available.
    """

    def __init__(self):
        self.ticket_list = []  # Initialize an empty list of tickets

    def add_ticket(self, ticket):
        """
        Add a ticket to the inventory.

        :param ticket: Ticket object to add
        """
        self.ticket_list.append(ticket)  # Add the ticket to the list

    def remove_ticket(self, ticket_id):
        """
        Remove a ticket from the inventory based on its ID.

        :param ticket_id: ID of the ticket to remove
        """
        # Filter out the ticket with the given ID
        self.ticket_list = [ticket for ticket in self.ticket_list if ticket.ticket_id != ticket_id]

    def update_availability(self):
        """
        Check the number of available tickets.

        :return: Number of tickets left in inventory
        """
        return len(self.ticket_list)  # Return the count of available tickets

    def __str__(self):
        """
        Return the status of the ticket inventory.
        """
        return f"Inventory: {len(self.ticket_list)} tickets available"

#PurchaseOrder Class
from enum import Enum

class PaymentMethod(Enum):
    """
    Enum for different payment methods.
    """
    CREDITCARD = 1
    DEBITCARD = 2
    DIGITALWALLET = 3

class PurchaseOrder:
    """
    A class representing a customer's purchase order.
    """
    def _init_(self, order_id, order_date, total_amount, payment_method):
        """
        Initializes a PurchaseOrder instance.

        :param order_id: Unique identifier for the order
        :param order_date: Date when the order was placed
        :param total_amount: Total cost of the order
        :param payment_method: Payment method used (from PaymentMethod enum)
        """
        self.order_id = order_id
        self.order_date = order_date
        self.total_amount = total_amount
        self.payment_method = payment_method

    def calculate_total(self):
        """Calculate the total price (include discount logic if needed)."""
        return self.total_amount

    def _str_(self):
        """Return a string representation of the PurchaseOrder."""
        return f"Order ID: {self.order_id}, Date: {self.order_date}, Total: {self.total_amount}, Payment: {self.payment_method.name}"

#Pickle for Saving and Loading Data

import pickle

class FileHandler:
    """
    Class to handle saving and loading data using Pickle.
    """
    def save_data(self, data, filename):
        """Save data to a binary file using Pickle."""
        with open(filename, 'wb') as f:
            pickle.dump(data, f)

    def load_data(self, filename):
        """Load data from a Pickle file."""
        try:
            with open(filename, 'rb') as f:
                return pickle.load(f)
        except FileNotFoundError:
            return []  # Return an empty list if the file is not found

#Testing the System
from enum import Enum

class TicketType(Enum):
    SINGLERACE = 1
    WEEKENDPASS = 2
    SEASONMEMBERSHIP = 3
    GROUPDISCOUNT = 4

class Ticket:
    def __init__(self, ticket_id, ticket_type, price, validity, race_date):
        self.ticket_id = ticket_id
        self.ticket_type = ticket_type
        self.price = price
        self.validity = validity
        self.race_date = race_date

    def __str__(self):
        return f"Ticket ID: {self.ticket_id}, Type: {self.ticket_type.name}, Price: {self.price}, Date: {self.race_date}"

class TicketInventory:
    def __init__(self):
        self.ticket_list = []

    def add_ticket(self, ticket):
        self.ticket_list.append(ticket)

    def remove_ticket(self, ticket_id):
        self.ticket_list = [ticket for ticket in self.ticket_list if ticket.ticket_id != ticket_id]

    def update_availability(self):
        return len(self.ticket_list)

    def display_all_tickets(self):
        if not self.ticket_list:
            print("No tickets available.")
        else:
            for ticket in self.ticket_list:
                print(ticket)

# Helper to display menu
def show_menu():
    print("\n--- Ticket Inventory Menu ---")
    print("1. Add ticket")
    print("2. Remove ticket")
    print("3. View inventory")
    print("4. Exit")

# Main program
if __name__ == "__main__":
    inventory = TicketInventory()

    while True:
        show_menu()
        choice = input("Enter your choice (1-4): ")

        if choice == "1":
            # Add a ticket
            ticket_id = input("Enter Ticket ID: ")
            print("Choose Ticket Type:")
            for t in TicketType:
                print(f"{t.value}. {t.name}")
            type_choice = int(input("Enter choice (1-4): "))
            ticket_type = TicketType(type_choice)

            price = float(input("Enter Ticket Price: "))
            validity = input("Enter Ticket Validity: ")
            race_date = input("Enter Race Date (YYYY-MM-DD): ")

            ticket = Ticket(ticket_id, ticket_type, price, validity, race_date)
            inventory.add_ticket(ticket)
            print("Ticket added successfully.")

        elif choice == "2":
            # Remove a ticket
            ticket_id = input("Enter Ticket ID to remove: ")
            inventory.remove_ticket(ticket_id)
            print("Ticket removed (if it existed).")

        elif choice == "3":
            # View tickets
            print("\nCurrent Tickets:")
            inventory.display_all_tickets()
            print(f"Total tickets: {inventory.update_availability()}")

        elif choice == "4":
            print("Exiting program.")
            break
        else:
            print("Invalid choice. Please try again.")


import tkinter as tk
from tkinter import messagebox
from user import User  # Importing the User class from previous code

# Sample in-memory user database (for testing only)
user_database = {}

# Main application window
root = tk.Tk()
root.title("Grand Prix Ticketing System")
root.geometry("600x500")  # Increased window size for better layout

# ---------------------------- Helper Functions ---------------------------- #

def login():
    username = username_entry.get()
    password = password_entry.get()
    
    # Check if user exists and password matches
    if username in user_database and user_database[username].get_password() == password:
        messagebox.showinfo("Login Success", f"Welcome {username}!")
    else:
        messagebox.showerror("Login Failed", "Invalid username or password")

def create_account():
    username = username_entry.get()
    password = password_entry.get()

    # Validate input
    if username in user_database:
        messagebox.showerror("Error", "Username already exists!")
    elif not username or not password:
        messagebox.showerror("Error", "Please enter both username and password")
    else:
        # Create a new user and store it in the database
        new_user = User(user_id=len(user_database)+1, name=username, email=f"{username}@example.com", password=password)
        user_database[username] = new_user
        messagebox.showinfo("Success", "Account created successfully!")

def delete_account():
    username = username_entry.get()
    # Remove user if exists
    if username in user_database:
        del user_database[username]
        messagebox.showinfo("Deleted", "Account deleted successfully")
    else:
        messagebox.showerror("Error", "User not found")

def modify_account():
    username = username_entry.get()
    new_password = password_entry.get()
    # Change password if user exists
    if username in user_database:
        user_database[username].set_password(new_password)
        messagebox.showinfo("Updated", "Password updated successfully")
    else:
        messagebox.showerror("Error", "User not found")

def display_user_details():
    username = username_entry.get()
    # Display user details if user exists
    if username in user_database:
        user = user_database[username]
        messagebox.showinfo("User Details", f"Username: {user.get_name()}\nEmail: {user.get_email()}")
    else:
        messagebox.showerror("Error", "User not found")

def view_tickets():
    # Show hardcoded ticket options
    messagebox.showinfo("Tickets", "Ticket options:\n1. Single Race - $100\n2. Weekend Pass - $250\n3. Season Membership - $800\n4. Group Discount - $350")

def admin_dashboard():
    # Simulate basic admin dashboard actions
    messagebox.showinfo("Admin Dashboard", "Admin Panel:\n- Tickets sold: 300\n- Discounts updated\n- Inventory managed")

def exit_app():
    root.destroy()

# ---------------------------- GUI Layout ---------------------------- #

# Title
title_label = tk.Label(root, text="Welcome to Grand Prix System", font=("Helvetica", 16, "bold"))
title_label.pack(pady=10)

# Username input
username_label = tk.Label(root, text="Username:")
username_label.pack()
username_entry = tk.Entry(root)
username_entry.pack()

# Password input
password_label = tk.Label(root, text="Password:")
password_label.pack()
password_entry = tk.Entry(root, show="*")  # Hide password
password_entry.pack()

# Buttons for account actions
login_button = tk.Button(root, text="Login", command=login)
login_button.pack(pady=5)

create_button = tk.Button(root, text="Create Account", command=create_account)
create_button.pack(pady=5)

delete_button = tk.Button(root, text="Delete Account", command=delete_account)
delete_button.pack(pady=5)

modify_button = tk.Button(root, text="Modify Password", command=modify_account)
modify_button.pack(pady=5)

display_button = tk.Button(root, text="Display User Details", command=display_user_details)
display_button.pack(pady=5)

# Ticket and admin options
view_button = tk.Button(root, text="View Tickets", command=view_tickets)
view_button.pack(pady=10)

admin_button = tk.Button(root, text="Admin Dashboard", command=admin_dashboard)
admin_button.pack(pady=5)

# Exit button
exit_button = tk.Button(root, text="Exit", command=exit_app)
exit_button.pack(pady=10)

# ---------------------------- Start GUI ---------------------------- #
root.mainloop()
